- Bottom bounds, the candles will NEVER be at a 'high', and vice versa. (True unless candle is extremely small).
- For defining touch areas on a trend channel, could use ML, or clever thresholds.
- Straight lines, y = mx + b. The least squares equation also helpful. 
- Use HLC/3 average rather than just 'close' etc.
- Trade how a coder sees.

Overview
Goal: "be there" with a good strat if it's +EV where we see a channel trend and potential breakout.
Example Process: We collect all upper band close breakout, for top 25 crypto 5m. Get ~5000 datapoint with returns. Then we can add some data info regarding every data point (distance vs ma200, atr/channel, etc.) and try to see if we can fit some pattern in positive returns with the data. 

Coding Process:
1. Run a function to 'identify a channel with 'live rolling' data'. For example, it finds the 3rd local high/local low, so that means enough bounces, and this a channel.
2. Fit a slope on all local high & low, and you remove/add them 1 by one until you find the slope with minimum error. Doesn't have to be perfect, minimum 3 datapoints for upper/lower bounds. Ignore outliers to help with accuracy.
3. Once we found the upper/lower bounds, check if slopes about equal, if so, we can say we have a channel. If the slopes are negative, look for a postive breakout. If we go near lower bound, don't care. And vice versa.
4. Example Strategy: So if we see 1-2-3 top, 1-2-3 bot, -> channel is confirmed. Now whenever price touches low, we enter in this trade. Use latest high as stoploss, risk = stoploss - current_price. TP 10% every 1 risk or something like that. Then you run backtest modifying that, and you can also optimise your strat.
5. How to 'scan/roll' through data? Window? (Window of 10 candles at a time?). Maximum channel length?
6. Maybe average price needs to be small and that can define a channel (lack of volatility, and linear price movement up or down)
7. Historical data fine for learning patterns/returns/fitting channels, But for trading strategies need the data to be 'rolling' and live. Roll through data just like day would pass, so (i) is “live” (:i) is what I can use. If you go through historical data simulating "live" by rolling through your dataframe, you can capture that without lookahead bias. Looking to get a snapshot of the channel when find one. Ideally: (length of channel before) + channel itself + (3 lengths of the channel afterwards, finding returns). Once get snapshot, we can add statistics to that (volume in breakout, distance from MA, etc.).
8. Weight the wicks different. Weight outliers different. (50% less weight on wicks, or remove em completely). It only takes two points to make a line and thus a slope.
9. +- 25% of the disance outside the channel is fine and still counts (Not including wicks?)
10. What constitutes a single 'cluster' or separate bounces on upper/lower bounds? (5 candles apart?) (If bunch of clusters, then after like 10 candles count as a 'new' bounce)
11. Specifically, if open/close is within 10-20% of boundary, either above or below, counts good as a touch. If more than 10-20% above or below boundary, then it invalidates. If within the channel, and 10-20% close enough to boundary, counts as a touch, but not if further away. (Wicks also count as boundary touches inside, but maybe weigh wicks less when they go outside the boundary, maybe up to 30-50% of channels diameter.)
12. The window search candle by candle to find the first and second points are the hardest. How tf is that done?